#!/usr/bin/env python3
"""
Read and parse binary log files generated by cache_ext_mglru_lc.

Binary format for cache_access events (64 bytes with padding):
    uint64_t timestamp;      // 8 bytes
    uint64_t time_delta;     // 8 bytes
    uint32_t major;          // 4 bytes
    uint32_t minor;          // 4 bytes
    uint64_t ino;            // 8 bytes
    uint64_t offset;         // 8 bytes
    bool is_sequential;      // 1 byte
    (7 bytes padding for alignment)
    uint64_t file_size;      // 8 bytes
    uint32_t frequency;      // 4 bytes
    (4 bytes padding at end)

Binary format for cache_insertion events (32 bytes):
    uint64_t timestamp;      // 8 bytes
    uint32_t major;          // 4 bytes
    uint32_t minor;          // 4 bytes
    uint64_t ino;            // 8 bytes
    uint64_t index;          // 8 bytes
"""

import struct
import sys
import argparse
from pathlib import Path


class CacheAccessEvent:
    # C struct has padding after bool to align uint64_t to 8-byte boundary
    # Layout: timestamp(8) time_delta(8) major(4) minor(4) ino(8) offset(8)
    #         is_sequential(1) padding(7) file_size(8) frequency(4) padding(4)
    FORMAT = '<QQIIQQ?7xQI4x'  # Little-endian, with 7 bytes padding after bool, 4 at end
    SIZE = struct.calcsize(FORMAT)

    def __init__(self, data):
        unpacked = struct.unpack(self.FORMAT, data)
        self.timestamp = unpacked[0]
        self.time_delta = unpacked[1]
        self.major = unpacked[2]
        self.minor = unpacked[3]
        self.ino = unpacked[4]
        self.offset = unpacked[5]
        self.is_sequential = unpacked[6]
        self.file_size = unpacked[7]
        self.frequency = unpacked[8]
    
    def __str__(self):
        return (f"a={self.timestamp} t={self.time_delta} d={self.major}:{self.minor} "
                f"i={self.ino} o={self.offset} s={1 if self.is_sequential else 0} "
                f"z={self.file_size} f={self.frequency}")


class CacheInsertionEvent:
    FORMAT = '<QIIQQ'  # Little-endian
    SIZE = struct.calcsize(FORMAT)
    
    def __init__(self, data):
        unpacked = struct.unpack(self.FORMAT, data)
        self.timestamp = unpacked[0]
        self.major = unpacked[1]
        self.minor = unpacked[2]
        self.ino = unpacked[3]
        self.index = unpacked[4]
    
    def __str__(self):
        return (f"t={self.timestamp} d={self.major}:{self.minor} "
                f"i={self.ino} x={self.index}")


def read_access_log(filepath, limit=None):
    """Read and parse cache access log file."""
    count = 0
    with open(filepath, 'rb') as f:
        while True:
            data = f.read(CacheAccessEvent.SIZE)
            if not data:
                break
            if len(data) < CacheAccessEvent.SIZE:
                print(f"Warning: Incomplete record at end of file ({len(data)} bytes)", 
                      file=sys.stderr)
                break
            
            event = CacheAccessEvent(data)
            print(f"tracer-cache-access: {event}")
            count += 1
            
            if limit and count >= limit:
                break
    
    return count


def read_insertion_log(filepath, limit=None):
    """Read and parse cache insertion log file."""
    count = 0
    with open(filepath, 'rb') as f:
        while True:
            data = f.read(CacheInsertionEvent.SIZE)
            if not data:
                break
            if len(data) < CacheInsertionEvent.SIZE:
                print(f"Warning: Incomplete record at end of file ({len(data)} bytes)", 
                      file=sys.stderr)
                break
            
            event = CacheInsertionEvent(data)
            print(f"tracer-cache-insertion: {event}")
            count += 1
            
            if limit and count >= limit:
                break
    
    return count


def main():
    parser = argparse.ArgumentParser(description='Read binary cache trace logs')
    parser.add_argument('logfile', help='Path to binary log file')
    parser.add_argument('--type', choices=['access', 'insertion'], 
                        help='Type of log file (auto-detected from filename if not specified)')
    parser.add_argument('--limit', type=int, help='Maximum number of records to read')
    parser.add_argument('--stats-only', action='store_true', 
                        help='Only show statistics, not individual records')
    
    args = parser.parse_args()
    
    # Auto-detect type from filename
    log_type = args.type
    if not log_type:
        if 'access' in Path(args.logfile).name:
            log_type = 'access'
        elif 'insertion' in Path(args.logfile).name:
            log_type = 'insertion'
        else:
            print("Error: Cannot auto-detect log type. Please specify --type", 
                  file=sys.stderr)
            sys.exit(1)
    
    # Read the log
    if args.stats_only:
        # Just count records without printing
        import os
        file_size = os.path.getsize(args.logfile)
        if log_type == 'access':
            count = file_size // CacheAccessEvent.SIZE
        else:
            count = file_size // CacheInsertionEvent.SIZE
        print(f"Total records: {count}")
    else:
        if log_type == 'access':
            count = read_access_log(args.logfile, args.limit)
        else:
            count = read_insertion_log(args.logfile, args.limit)
        
        print(f"\nTotal records read: {count}", file=sys.stderr)


if __name__ == '__main__':
    main()

